#!/usr/bin/env python
from fileprogressadapter import FileProgressProducer
from filedownloadprotocol import FileDownloadProtocol
from StringIO import StringIO
from httprequests import http, HTTPQueryRunner
import routing
import sys
import json
from playlistprint import printPlaylist
from twisted.web.client import FileBodyProducer
import re
import mimetypes

youtube_regex = "^([a-zA-Z0-9_-]+)$|^http://[^/]+youtube\.com/watch\?v=([a-zA-Z0-9_-]+)"


def discard(body):
	pass

def printMe(body):
	print body

def printPlaylist_resp(body):
	printPlaylist(json.loads(body))

# Temp queueing
def add_youtube(link):
	m = re.compile(youtube_regex).match(link)
	vId = m.group(1) or m.group(2)
	http.reactOn(http.sendSimpleCB("ENQUEUE", "/youtube/video/" + vId, discard))

def add_upload(files):
	r = upload_files(files)
	if r == None:
		print("No files specified for upload.")
	else:
		http.reactOn(r)

def onUploadProgress(fil):
	def onUploadProgress_inner(progress):
		sys.stdout.write("Uploading '%s'... %d%%\r" % (fil, (progress * 100)))
		sys.stdout.flush()
	return onUploadProgress_inner

def upload_files(files):
	if len(files) == 0:
		return None

	fil = files[0]
	return http.sendCB("POST", "/upload", upload_on_response(fil,files[1:]), FileProgressProducer(fil,onUploadProgress(fil)))

def upload_on_response(curfile,files):
	def on_response(response):
		sys.stdout.write("Uploading '%s'... done.\n" % curfile)
		sys.stdout.flush()
		return upload_files(files)
	return on_response

def add_stream(uri):
	http.reactOn(http.sendSimpleCB("POST", "/stream", discard, FileBodyProducer(StringIO(uri))))

# Queue management
def playlist():
	http.reactOn(http.sendSimpleCB("GET", "/queue", printPlaylist_resp))

def playlist_raw():
	http.reactOn(http.sendSimpleCB("GET", "/queue", printMe))

def flush():
	http.reactOn(http.sendSimpleCB("DELETE", "/queue", discard))

def history():
	http.reactOn(http.sendSimpleCB("GET", "/history", printPlaylist_resp))

def history_raw():
	http.reactOn(http.sendSimpleCB("GET", "/history", printMe))

def leech(idx):
	def onProgress(bytes):
		sys.stdout.write("Downloading... %d kB\r" % (bytes / 1024))
		sys.stdout.flush()

	def requestMediaForIdx(body):
		hist = json.loads(body)
		media = hist[idx]
		ext = "unknowntype"

		if "mimetype" in media["info"]:
			ext = mimetypes.guess_extension(media["info"]["mimetype"])
		print "using extension %s" % ext

		outfile = open("%s - %s%s" % (media["info"]["artist"],media["info"]["title"],ext), "w")
		fdl = FileDownloadProtocol(outfile, onProgress)
		return http.sendWithReceiver("DOWNLOAD","/queue/" + media["id"].encode('latin-1'),fdl)

	def printDone(ignore):
		sys.stdout.write("Downloading... done.                        \n")
		sys.stdout.flush()

	d = http.sendSimpleCB("GET", "/history", requestMediaForIdx)
	d.addCallback(printDone)
	http.reactOn(d)

# Current
def next():
	http.reactOn(http.sendSimpleCB("NEXT", "/control/current", printMe))
def previous():
	http.reactOn(http.sendSimpleCB("PREVIOUS", "/control/current", printMe))
def pause():
	http.reactOn(http.sendSimpleCB("PAUSE", "/control/current", printMe))
def stop():
	http.reactOn(http.sendSimpleCB("STOP", "/control/current", printMe))
def replay():
	http.reactOn(http.sendSimpleCB("REPLAY", "/control/current", printMe))

# Favs
def favorite_add(type,name,rest):
	http.reactOn(http.sendSimpleCB("POST", "/favorites", discard, FileBodyProducer(StringIO(json.dumps({
		"type": type,
		"name": name,
		"options": rest
	})))))

# Volume
def volume_get():
	http.reactOn(http.sendSimpleCB("GET", "/control/volume", printMe))

def volume_set(volume):
	http.reactOn(http.sendSimpleCB("PUT", "/control/volume", discard, FileBodyProducer(StringIO(str(volume)))))



def routeMain(argv):
	r = routing.Router(argv)
	# Queue management
	r.match        ( lambda b: playlist(), [] )
	r.pl           ( lambda b: playlist_raw() )
	r.flush        ( lambda b: flush() )
	r.history      ( lambda b: history() )
	r.hl           ( lambda b: history_raw() )
	r.leech        ( lambda b: leech(int(b["idx"])),
	                 [":idx"] )

	# Enqueueing
	r.add          ( lambda b: add_youtube(b["link"]),
	                 [["youtube","yt","y","tube"],":link"],
	                 { "link": youtube_regex } )
	r.add          ( lambda b: add_upload(b["..."]),
		             [["upload","ul","u","uload"],"..."] )
	r.add          ( lambda b: add_stream(b["uri"]),
		             [["stream","str","s"],":uri"] )

	# Favs
	r.fav          ( lambda b: favorite_add(b["type"],b["name"],b["..."]),
					 ["add",":type",":name","..."],
					 { "type": "stream|youtube" } )

	# Current
	r.skip         ( lambda b: next() )
	r.next         ( lambda b: next() )
	r.previous     ( lambda b: previous() )
	r.pause        ( lambda b: pause() )
	r.stop         ( lambda b: stop() )
	r.replay       ( lambda b: replay() )
	r.play         ( lambda b: replay() )

	# Controls
	r.volume       ( lambda b: volume_get() )
	r.v            ( lambda b: volume_get() )
	r.volume       ( lambda b: volume_set(int(b["val"])),
	                 [":val"] )
	r.v            ( lambda b: volume_set(int(b["val"])),
	                 [":val"] )

	r.finalize()

routeMain(sys.argv[1:])
